{"./":{"url":"./","title":"webBook","keywords":"","body":"webBook webBook "},"Base/Css/":{"url":"Base/Css/","title":"Css基础","keywords":"","body":"前端基础之css "},"Base/Css/常见布局.html":{"url":"Base/Css/常见布局.html","title":"常见布局","keywords":"","body":""},"Base/Css/Flex布局.html":{"url":"Base/Css/Flex布局.html","title":"Flex布局","keywords":"","body":""},"Base/Css/BFC块格式化上下文.html":{"url":"Base/Css/BFC块格式化上下文.html","title":"BFC块格式化上下文","keywords":"","body":"BFC的定义 BFC全称为block formatting context，中文为“块级格式化上下文”。 表现原则:如果一个元素具有 BFC，内部子元素再怎么翻江倒海、翻云覆雨，都不会影响外部的元素。所以，BFC 元素是不可能发生 margin 重叠的，因为 margin 重叠是会影响外面的元素的; BFC 元素也可以用来清除浮动的影响，因为如果不清除，子元素 浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 BFC 元素的子元素不会 影响外部元素的设定。 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。 浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。换言之，只要元素符合上面任意一个条件，就无须使用 clear:both 属性去清除浮动的 影响了 遇到哪些问题需要用到BFC 同一个盒子内的外边距合并 浮动导致的盒子高度塌陷 等，这些问题都可以通过触发BFC 来解决 "},"Base/Html/":{"url":"Base/Html/","title":"Html基础","keywords":"","body":"前端基础之css "},"Base/Javascript/":{"url":"Base/Javascript/","title":"Javascript基础","keywords":"","body":"前端基础之css "},"Base/Javascript/基础深入/":{"url":"Base/Javascript/基础深入/","title":"基础深入","keywords":"","body":"前端基础之css "},"Base/Javascript/基础深入/this指向.html":{"url":"Base/Javascript/基础深入/this指向.html","title":"this指向","keywords":"","body":"this是javascript中最常用到的关键词之一， javascript中this对象的指向问题是一个很重要的问题，理解并正确使用它是一个javascript开发者必须具备的能力。 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 调用位置 在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。只有仔细分析调用位置才能回答这个问题:这个 this 到底引 用的是什么? 最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的 调用位置就在当前正在执行的函数的前一个调用中。调用栈可以想象成一个函数调用链，在浏览器的调试工具中可以打断点来查看当前断点的调用栈信息 可以看到当前调用栈的位置在foo,下个调用位置是bar,在当前的调用环境下this 默认指向了windows对象。 绑定规则 我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。 你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。 默认绑定 首先要介绍的是最常用的函数调用类型:独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。 function foo() { console.log(this.a); } var a = 2; foo(); // 2 声明在全局作用域中的变量(比如 var a = 2)就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的。 当调用 foo() 时，this.a 被解析成了全局变量 a。因为函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。 那么我们怎么知道这里应用了默认绑定呢?可以通过分析调用位置来看看 foo() 是如何调 用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，其调用栈是处在全局作用域中，因此只能使用 默认绑定，无法应用其他规则。 注意 ：使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到undefined。 隐式绑定 另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象\"拥 有\"或者\"包含\"它。 无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说: function foo() { console.log(this.a); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐式丢失 当我们在用隐式绑定的时候可能会犯一个错误，被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者undefined 上，取决于是否是严格模式。 function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名! var a = \"oops, global\"; // a 是全局对象的属性 bar(); // \"oops, global\" 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 显式绑定 在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢? JavaScript 中的\"所有\"函数都有一些有用的特性可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用call(..) 和 apply(..) 方法。 function foo() { console.log( this.a ); } var obj = { a:2 }; foo.call( obj ); // 2 通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 硬绑定 显式绑定仍然无法解决我们之前提出的丢失绑定问题,但是显式绑定的一个变种可以解决这个问题。 function foo() { console.log(this.a); } var obj = { a: 2 }; var bar = function () { foo.call(obj); }; bar(); // 2 setTimeout(bar, 100); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call(window); // 2 我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值: function foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = function () { return foo.apply(obj, arguments); }; var b = bar(3); // 2 3 console.log(b); // 5 new绑定 在传统的面向类的语言中，\"构造函数\"是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的: something = new MyClass(..); JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。 首先我们重新定义一下 JavaScript 中的\"构造函数\"。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它: 15.7.2 Number 构造函数当 Number 在 new 表达式中被调用时，它是一个构造函数:它会初始化新创建的 对象。 所以，包括内置对象函数(比如 Number(..))在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别:实际上并不存在所谓的\"构造函数\"，只有对于函数的\"构造调用\"。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 function foo(a) { this.a = a; } var bar = new foo(2); console.log(bar.a); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 优先级 现在我们已经了解了函数调用中 this 绑定的四条规则，你需要做的就是找到函数的调用位 置并判断应当应用哪条规则。但是，如果某个调用位置可以应用多条规则该怎么办?为了 解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下: function foo() { console.log(this.a); } var obj1 = { a: 2, foo: foo }; var obj2 = { a: 3, foo: foo }; obj1.foo(); // 2 obj2.foo(); // 3 obj1.foo.call(obj2); // 3 obj2.foo.call(obj1); // 2 可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低: function foo(something) { this.a = something; } var obj1 = { foo: foo }; var obj2 = {}; obj1.foo(2); console.log(obj1.a); // 2 obj1.foo.call(obj2, 3); console.log(obj2.a); // 3 var bar = new obj1.foo(4); console.log(obj1.a); // 2 console.log(bar.a); // 4 可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢? new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。 function foo(something) { this.a = something; } var obj1 = {}; var bar = foo.bind(obj1); bar(2); console.log(obj1.a); // 2 var baz = new bar(3); console.log(obj1.a); // 2 console.log(baz.a); // 3 出乎意料! bar 被硬绑定到 obj1 上，但是 new bar(3)并没有向我们预料的那样把obj1.a修改为 3。相反，new 修改了硬绑定(到 obj1 的)调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。 判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断: 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 就是这样。 对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 不过......凡事总有例外。 "},"Algorithm/DataStructure/":{"url":"Algorithm/DataStructure/","title":"数据结构","keywords":"","body":"前端基础之css "},"Algorithm/Algorithm/":{"url":"Algorithm/Algorithm/","title":"算法","keywords":"","body":"前端基础之css "},"Tool/Yarn/":{"url":"Tool/Yarn/","title":"Yarn","keywords":"","body":""},"Tool/Npm/":{"url":"Tool/Npm/","title":"Npm","keywords":"","body":""},"Tool/Npm/npm常用命令.html":{"url":"Tool/Npm/npm常用命令.html","title":"npm常用命令","keywords":"","body":"npm 常用命令行总结 npm是什么 NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 npm install安装模块 基础语法 ``` javascript npm install (with no args, in package dir) npm install [/] npm install [/]@ npm install [/]@ npm install [/]@ npm install npm install npm install alias: npm i common options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run] 安装包，默认会安装最新的版本 #### npm uninstall 卸载模块 - 基础语法 ``` javascript npm uninstall [/][@]... [-S|--save|-D|--save-dev|-O|--save-optional] aliases: remove, rm, r, un, unlink npm update 更新模块 基础语法npm update [-g] [...] npm outdated 检查模块是否已经过时 基础语法npm outdated [[/] ...] npm ls 查看安装的模块 基础语法npm ls [[/] ...] aliases: list, la, ll 查看全局安装的模块及依赖 npm ls -g npm init 在项目中引导创建一个package.json文件 安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用，也说package.json在项目中是必不可少的 基础语法npm init [-f|--force|-y|--yes] npm help 查看某条命令的详细帮助 基础语法npm help [] 例如输入npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.htmlnpm help install npm root 查看包的安装路径 输出 node_modules的路径 npm root [-g] npm config 管理npm的配置路径 基础语法npm config set [-g|--global] npm config get npm config delete npm config list npm config edit npm get npm set [-g|--global] 经常用于设置镜像npm config set registry=\"http://r.cnpmjs.org\" 如安装淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org npm cache 管理模块的缓存 基础语法npm cache add npm cache add npm cache add npm cache add @ npm cache ls [] npm cache clean [] 最常用命令清除npm本地缓存npm cache clean npm start 启动模块 基础语法npm start [-- ] 该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如\"scripts\": { \"start\": \"gulp -ws\" } 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。 如果package.json文件没有设置start，则将直接启动node server.js npm stop 停止模块 基础语法npm stop [-- ] npm restart 重新启动模块 基础语法npm restart [-- ] npm test 测试模块 基础语法npm test [-- ] npm tst [-- ] 该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如\"scripts\": { \"test\": \"gulp release\" }, 此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 npm version 查看模块版本 基础语法 ``` javascript npm version [ | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git] 'npm [-v | --version]' to print npm version 'npm view version' to view a package's published version 'npm ls' to inspect current package/dependency versions 查看模块的版本 ``` javascript npm version 例： { store_eve: '0.1.0', npm: '6.9.0', ares: '1.10.1-DEV', cldr: '32.0', http_parser: '2.8.0', icu: '60.1', modules: '57', nghttp2: '1.25.0', node: '8.11.1', openssl: '1.0.2o', tz: '2017c', unicode: '10.0', uv: '1.19.1', v8: '6.2.414.50', zlib: '1.2.11' } npm view 查看模块的注册信息 基础语法 ``` javascript npm view [/][@] [[.]...] aliases: info, show, v 查看模块的依赖关系 ``` javascript npm view gulp dependencies 查看模块的源文件地址 npm view gulp repository.url 查看模块的贡献者，包含邮箱地址 npm view npm contributors npm adduser 用户登录 基础语法npm adduser [--registry=url] [--scope=@orgname] [--always-auth] 发布模板到npm社区前需要先登录，然后再进入发布的操作 npm publish 发布模块 基础语法 ``` javascript npm publish [|] [--tag ] [--access ] Publishes '.' if no argument supplied Sets tag 'latest' if no --tag specified #### npm access 在发布的包上设置访问级别 - 基础语法 ``` javascript npm access public [] npm access restricted [] npm access grant [] npm access revoke [] npm access ls-packages [||] npm access ls-collaborators [ []] npm access edit [] "},"Base/Javascript/专题/":{"url":"Base/Javascript/专题/","title":"专题深入","keywords":"","body":"前端基础之css "},"Base/Javascript/专题/跨域.html":{"url":"Base/Javascript/专题/跨域.html","title":"跨域","keywords":"","body":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 资源跳转： A链接、重定向、表单提交 资源嵌入： link、script、img、frame 等dom标签，还有样式中background:url()、@font-face()等文件外链 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送; 常见跨域场景 跨域解决方案 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 一、 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 原生实现： var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } 服务端返回如下（返回时即执行全局函数）： handleCallback({\"status\": true, \"user\": \"admin\"}) jquery ajax： $.ajax({ url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"handleCallback\", // 自定义回调函数名 data: {} }); vue.js： this.$http.jsonp('http://www.domain2.com:8080/login', { params: {}, jsonp: 'handleCallback' }).then((res) => { console.log(res); }) 后端node.js代码示例： var querystring = require('querystring'); var http = require('http'); var server = http.createServer(); server.on('request', function(req, res) { var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 父窗口：(http://www.domain.com/a.html) document.domain = 'domain.com'; var user = 'admin'; 子窗口：(http://child.domain.com/b.html) document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---> ' + window.parent.user); 三、 location.hash + iframe跨域 实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + '#user=admin'; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert('data from c.html ---> ' + res); } b.html：(http://www.domain2.com/b.html) var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; }; c.html：(http://www.domain1.com/c.html) // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); }; 四、 window.name + iframe跨域 window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) var proxy = function(url, callback) { var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据 proxy('http://www.domain2.com/b.html', function(data){ alert(data); }); proxy.html：(http://www.domain1.com/proxy.... 中间代理页，与a.html同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) window.name = 'This is domain2 data!'; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域 postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： a. 页面和其打开的新窗口的数据传递 b. 多窗口之间消息传递 c. 页面与嵌套的iframe消息传递 d. 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。 a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---> ' + e.data); }, false); b.html：(http://www.domain2.com/b.html) // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---> ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false); 六、 跨域资源共享（CORS） 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 前端设置： 原生ajax // 前端设置是否带cookie xhr.withCredentials = true; 示例代码： var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open('post', 'http://www.domain2.com:8080/login', true); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('user=admin'); xhr.onreadystatechange = function() { if (xhr.readyState == 4 && xhr.status == 200) { alert(xhr.responseText); } }; jQuery ajax $.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ... }); vue框架axios设置：axios.defaults.withCredentials = truevue-resource设置：Vue.http.options.credentials = true 服务端设置： 若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 Java后台： /* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/' response.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示 response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头 response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type,X-Requested-With\"); Nodejs后台示例： var http = require('http'); var server = http.createServer(); var qs = require('querystring'); server.on('request', function(req, res) { var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener('end', function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); }); }); server.listen('8080'); console.log('Server is running at port 8080...'); 七、 nginx代理跨域 1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location / { add_header Access-Control-Allow-Origin *; } 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。nginx具体配置： #proxy服务器 server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问nginx中的代理服务器 xhr.open('get', 'http://www.domain1.com:81/?user=admin', true); xhr.send(); Nodejs后台示例： var http = require('http'); var server = http.createServer(); var qs = require('querystring'); server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true); xhr.send(); 中间件服务器： var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 })); app.listen(3000); console.log('Proxy server is listen at port 3000...'); Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。webpack.config.js部分配置： module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }], noInfo: true } } 九、 WebSocket协议跨域 WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 前端代码： user input： var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---> ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); }; Nodejs socket后台： var http = require('http'); var socket = require('socket.io'); // 启http服务 var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); // 监听socket连接 socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---> ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); }); }); "}}