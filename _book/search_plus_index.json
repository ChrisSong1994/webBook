{"./":{"url":"./","title":"webBook","keywords":"","body":"webBook webBook "},"Base/Css/":{"url":"Base/Css/","title":"Css基础","keywords":"","body":"前端基础之css "},"Base/Css/常见布局.html":{"url":"Base/Css/常见布局.html","title":"常见布局","keywords":"","body":"两列布局 一、左列定宽,右列自适应 1. 利用float+margin 左列不定宽 右列自适应 #left { margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00; } #right { overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0; } 原理：#left不设宽度左浮动，#right触发bfc达到自适应 优缺点：优点：代码简单，容易理解，无需关注宽度，利用bfc达到自适应效果缺点：#right设置margin-left需要大于#left的宽度才有效，或者直接给#left设置margin-right 2. 使用flex实现 左列不定宽 右列自适应 #parent{display: flex;} #left { /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00; } #right { height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/ } 原理：flex设置排列方式、对齐方式罢了，请查阅文末flex阅读推荐 优缺点:优点：简单灵活；功能强大缺点：PC端兼容性不好，移动端（Android4.0+） flex务必带上兼容，写法请参考文末阅读推荐，也可以使用autoprefixer 3. 使用float+overflow 左列定宽 右列自适应 #left { background-color: #f00; float: left; width: 100px; height: 500px; } #right { background-color: #0f0; height: 500px; overflow: hidden; /*触发bfc达到自适应*/ } 原理：#left左浮动，#right触发bfc达到自适应 优缺点：优点：代码简单；容易理解；无需关注定宽的宽度，利用bfc达到自适应效果缺点：#right设置margin-left需要大于#left的宽度才有效，或者直接给#left设置margin-right 4. 使用position实现 左列定宽 右列自适应 #parent{position: relative;} /*父相*/ #left { position: absolute; /*子绝*/ top: 0; left: 0; background-color: #f00; width: 100px; height: 500px; } #right { position: absolute; /*子绝*/ top: 0; left: 100px; /*值大于等于#left的宽度*/ right: 0; background-color: #0f0; height: 500px; } 原理：利用绝对定位算好宽高固定好两个盒子的位置 优缺点:优点：容易理解；兼容性好代码较多；脱离文档流；左边盒子的width需要对应右边盒子的left值 5. 使用flex实现 左列定宽 右列自适应 #parent{ width: 100%; height: 500px; display: flex; } #left { width: 100px; background-color: #f00; } #right { flex: 1; /*均分了父元素剩余空间*/ background-color: #0f0; } 原理：flex设置排列方式、对齐方式罢了，请查阅文末flex阅读推荐 优缺点:优点：简单灵活；功能强大缺点：PC端兼容性不好，移动端（Android4.0+） flex务必带上兼容，写法请参考文末阅读推荐，也可以使用autoprefixer 6. 使用Grid实现 左列定宽 右列自适应 #parent { width: 100%; height: 500px; display: grid; grid-template-columns: 100px auto; /*设定2列就ok了,auto换成1fr也行*/ } #left {background-color: #f00;} #right {background-color: #0f0;} 原理：css grid布局，请查看文末的阅读推荐 优缺点:优点：灵活划分网格区域；新型布局利器，适用于页面三维布局缺点：兼容性不好，移动端（Android5.0+） 二、一列不定,一列自适应 1. 使用float+overflow 左列不定宽 右列自适应 #left { margin-right: 10px; float: left; /*只设置浮动,不设宽度*/ height: 500px; background-color: #f00; } #right { overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0; } 原理：#left不设宽度左浮动，#right触发bfc达到自适应 优缺点：优点：代码简单，容易理解，无需关注宽度，利用bfc达到自适应效果缺点：#right设置margin-left需要大于#left的宽度才有效，或者直接给#left设置margin-right 2. 使用flex实现 左列不定宽 右列自适应 #parent{display: flex;} #left { /*不设宽度*/ margin-right: 10px; height: 500px; background-color: #f00; } #right { height: 500px; background-color: #0f0; flex: 1; /*均分#parent剩余的部分*/ } 原理：flex设置排列方式、对齐方式罢了，请查阅文末flex阅读推荐 优缺点:优点：简单灵活；功能强大缺点：PC端兼容性不好，移动端（Android4.0+） flex务必带上兼容，写法请参考文末阅读推荐，也可以使用autoprefixer 3. 使用Grid实现 左列不定宽 右列自适应 #parent{ display: grid; grid-template-columns: auto 1fr; /*auto和1fr换一下顺序就是左列自适应,右列不定宽了*/ } #left { margin-right: 10px; height: 500px; background-color: #f00; } #right { height: 500px; background-color: #0f0; } 原理：css grid布局，请查看文末的阅读推荐 优缺点:优点：灵活划分网格区域；新型布局利器，适用于页面三维布局缺点：兼容性不好，移动端（Android5.0+） 小结： 两列布局我们用得比较多的就是浮动，然后最简单就是把另外那个不是浮动的盒子触发bfc以达到自适应效果就O了。其次就是设置对应固宽值的的一些margin、padding去改变盒子的排布以达到我们的目的； 除了浮动，我们还可以用绝对定位，计算好宽高、位置去设置样式，这个简单也容易理解，就是脱离文档流并且代码稍微多了一点； 还有就是css table布局，其实这个挺强大的，也简单，兼容性不错（ie8+），但就是table表现的bug太多，不感知margin之类的一些属性。当然，要是需求足够，完全是可以先考虑这个的； 移动端兼容性允许的情况下能用flex就用flex，务必带上兼容，写法可参考文末阅读推荐，也可以使用Autoprefixer； 三列布局 一、 两列定宽,一列自适应 1. 使用float+margin 左列定宽 中间定宽 右列自适应 #parent{min-width: 310px;} /*100+10+200,防止宽度不够,子元素换行*/ #left { margin-right: 10px; /*#left和#center间隔*/ float: left; width: 100px; height: 500px; background-color: #f00; } #center{ float: left; width: 200px; height: 500px; background-color: #eeff2b; } #right { margin-left: 320px; /*等于#left和#center的宽度之和加上间隔,多出来的就是#right和#center的间隔*/ height: 500px; background-color: #0f0; } 原理：两个盒子浮动，另一个盒子计算好两个盒子的宽度、间隔之和设置一个margin值 优缺点:优点：代码简单；容易理解；兼容性好缺点：margin或padding的值要对应好；父元素宽度不够浮动元素会换行 2. 使用float+overflow 左列定宽 中间定宽 右列自适应 #parent{min-width: 320px;} /*100+10+200+20,防止宽度不够,子元素换行*/ #left { margin-right: 10px; /*间隔*/ float: left; width: 100px; height: 500px; background-color: #f00; } #center{ margin-right: 10px; /*在此定义和#right的间隔*/ float: left; width: 200px; height: 500px; background-color: #eeff2b; } #right { overflow: hidden; /*触发bfc*/ height: 500px; background-color: #0f0; } 原理：两个盒子浮动，另一个盒子触发bfc达到自适应 优缺点：优点：代码简单，容易理解，无需关注定宽的宽度，利用bfc达到自适应效果缺点：#right设置margin-left需要大于左边两个盒子宽度、间隔之和才有效。或者直接给#center设置margin-right；父元素宽度不够，浮动元素换行 3. 使用position实现 左列定宽 中间定宽 右列自适应 #parent {position: relative;} /*父相*/ #left { position: absolute; /*子绝*/ top: 0; left: 0; width: 100px; height: 500px; background-color: #f00; } #center { position: absolute; /*子绝*/ left: 100px; /*对应#left的width值*/ top: 0; width: 200px; height: 500px; background-color: #eeff2b; } #right { position: absolute; /*子绝*/ left: 300px; /*对应#left和#center的width值之和*/ top: 0; right: 0; height: 500px; background-color: #0f0; } 原理：计算好盒子的宽度和间隔去设置位置 优缺点：优点：容易理解；兼容性比较好；改变相对灵活缺点：需手动计算宽度、间隔之和确定位置； 4. 使用flex实现 左列定宽 中间定宽 右列自适应 #parent { height: 500px; display: flex; } #left { margin-right: 10px; /*间距*/ width: 100px; background-color: #f00; } #center { margin-right: 10px; /*间距*/ width: 200px; background-color: #eeff2b; } #right { flex: 1; /*均分#parent剩余的部分达到自适应*/ background-color: #0f0; } 原理：flex设置排列方式、对齐方式罢了，请查阅文末flex阅读推荐 优缺点:优点：简单灵活；功能强大缺点：PC端兼容性不好，移动端（Android4.0+） flex务必带上兼容，写法请参考文末阅读推荐，也可以使用autoprefixer 5. 使用Grid实现 左列定宽 中间定宽 右列自适应 #parent { height: 500px; display: grid; grid-template-columns: 100px 200px auto; /*设置3列,固定第一第二列的宽度,第三列auto或者1fr*/ } #left { margin-right: 10px; /*间距*/ background-color: #f00; } #center { margin-right: 10px; /*间距*/ background-color: #eeff2b; } #right {background-color: #0f0;} 原理：css grid布局，请查看文末的阅读推荐 优缺点:优点：灵活划分网格区域；新型布局利器，适用于页面三维布局缺点：兼容性不好，移动端（Android5.0+） 二、 两侧定宽,中间自适应 1.双飞翼布局方法 中间自适应 左列定宽 右列定宽 #header { height: 60px; background-color: #ccc; } #left { float: left; width: 100px; height: 500px; margin-left: -100%; /*调整#left的位置,值等于自身宽度*/ background-color: #f00; opacity: 0.5; } #center { height: 500px; float: left; width: 100%; background-color: #eeff2b; } #center_inbox{ height: 480px; border: 1px solid #000; margin: 0 220px 0 120px; /*关键!!!左右边界等于左右盒子的宽度,多出来的为盒子间隔*/ } #right { float: left; width: 200px; height: 500px; margin-left: -200px; /*使right到指定的位置,值等于自身宽度*/ background-color: #0f0; opacity: 0.5; } #footer { clear: both; /*注意清除浮动!!*/ height: 60px; background-color: #ccc; } 2. 圣杯布局方法 中间自适应 左列定宽 右列定宽 #header{ height: 60px; background-color: #ccc; } #parent { height: 500px; padding: 0 215px 0 115px; /*为了使#center摆正,左右padding分别等于左右盒子的宽,可以结合左右盒子相对定位的left调整间距*/ } #left { margin-left: -100%; /*使#left上去一行*/ position: relative; left: -115px; /*相对定位调整#left的位置,正值大于或等于自身宽度*/ float: left; width: 100px; height: 500px; background-color: #f00; opacity: 0.5; } #center { float: left; width: 100%; /*由于#parent的padding,达到自适应的目的*/ height: 500px; box-sizing: border-box; border: 1px solid #000; background-color: #eeff2b; } #right { position: relative; left: 215px; /*相对定位调整#right的位置,大于或等于自身宽度*/ width: 200px; height: 500px; margin-left: -200px; /*使#right上去一行*/ float: left; background-color: #0f0; opacity: 0.5; } #footer{ height: 60px; background-color: #ccc; } 3.使用Grid实现 中间自适应 左列定宽 右列定宽 #parent { height: 500px; display: grid; grid-template-columns: 100px auto 200px; /*设定3列*/ grid-template-rows: 60px auto 60px; /*设定3行*/ /*设置网格区域分布*/ grid-template-areas: \"header header header\" \"leftside main rightside\" \"footer footer footer\"; } #header { grid-area: header; /*指定在哪个网格区域*/ background-color: #ccc; } #left { grid-area: leftside; background-color: #f00; opacity: 0.5; } #center { grid-area: main; /*指定在哪个网格区域*/ margin: 0 15px; /*设置间隔*/ border: 1px solid #000; background-color: #eeff2b; } #right { grid-area: rightside; /*指定在哪个网格区域*/ background-color: #0f0; opacity: 0.5; } #footer { grid-area: footer; /*指定在哪个网格区域*/ background-color: #ccc; } 4. 使用flex实现 左列定宽 中间自适应 右列定宽 #parent { height: 500px; display: flex; } #left { width: 100px; background-color: #f00; } #center { flex: 1; /*均分#parent剩余的部分*/ background-color: #eeff2b; } #right { width: 200px; background-color: #0f0; } 5. 使用position实现 左列定宽 中间自适应 右列定宽 #parent {position: relative;} /*父相*/ #left { position: absolute; /*子绝*/ top: 0; left: 0; width: 100px; height: 500px; background-color: #f00; } #center { height: 500px; margin-left: 100px; /*大于等于#left的宽度,或者给#parent添加同样大小的padding-left*/ margin-right: 200px; /*大于等于#right的宽度,或者给#parent添加同样大小的padding-right*/ background-color: #eeff2b; } #right { position: absolute; /*子绝*/ top: 0; right: 0; width: 200px; height: 500px; background-color: #0f0; } 小结： 两列定宽，一列自适应布局，个人推荐方法就是两列浮动，一列触发bfc去达到自适应效果，代码较少，需要注意的就是清除浮动和margin的设置以及父元素空间是否足够； 只要是三列布局，其实都可以用绝对定位去实现，理解起来不难，而且变化灵活，不太好的就是脱离文档流，导致不一定能撑起父元素高度，对于下面排布的盒子会有影响，还有需要手动计算边距的值去排布盒子； 其次可以选用css table布局，代码是最少的，就是bug有点多； 两侧定宽,中间自适应，就必须得说说圣杯布局和双飞翼布局，这两个是比较难理解的，然后圣杯布局有缺陷，如果浏览器无限变窄，圣杯布局将会乱套。绝对定位布局在不等高的时候也会对下面盒子排布产生影响。那么双飞翼布局似乎是最好的选择了。不管怎样，圣杯布局和双飞翼布局都是要好好学习的，这样对盒模型和浮动会有更深的理解； 移动端兼容性允许的情况下能用flex就用flex，务必带上兼容，写法可参考文末阅读推荐，也可以使用Autoprefixer； "},"Base/Css/Flex布局.html":{"url":"Base/Css/Flex布局.html","title":"Flex布局","keywords":"","body":""},"Base/Css/BFC块格式化上下文.html":{"url":"Base/Css/BFC块格式化上下文.html","title":"BFC块格式化上下文","keywords":"","body":"BFC的定义 BFC全称为block formatting context，中文为“块级格式化上下文”。 表现原则:如果一个元素具有 BFC，内部子元素再怎么翻江倒海、翻云覆雨，都不会影响外部的元素。所以，BFC 元素是不可能发生 margin 重叠的，因为 margin 重叠是会影响外面的元素的; BFC 元素也可以用来清除浮动的影响，因为如果不清除，子元素 浮动则父元素高度塌陷，必然会影响后面元素布局和定位，这显然有违 BFC 元素的子元素不会 影响外部元素的设定。 一个块格式化上下文（block formatting context） 是Web页面的可视化CSS渲染出的一部分。它是块级盒布局出现的区域，也是浮动层元素进行交互的区域。 一个块格式化上下文由以下之一创建： 根元素或其它包含它的元素 浮动元素 (元素的 float 不是 none) 绝对定位元素 (元素具有 position 为 absolute 或 fixed) 内联块 (元素具有 display: inline-block) 表格单元格 (元素具有 display: table-cell，HTML表格单元格默认属性) 表格标题 (元素具有 display: table-caption, HTML表格标题默认属性) 具有overflow 且值不是 visible 的块元素， display: flow-root column-span: all 应当总是会创建一个新的格式化上下文，即便具有 column-span: all 的元素并不被包裹在一个多列容器中。 一个块格式化上下文包括创建它的元素内部所有内容，除了被包含于创建新的块级格式化上下文的后代元素内的元素。 块格式化上下文对于定位 (参见 float) 与清除浮动 (参见 clear) 很重要。定位和清除浮动的样式规则只适用于处于同一块格式化上下文内的元素。 浮动不会影响其它块格式化上下文中元素的布局，并且清除浮动只能清除同一块格式化上下文中在它前面的元素的浮动。换言之，只要元素符合上面任意一个条件，就无须使用 clear:both 属性去清除浮动的 影响了 遇到哪些问题需要用到BFC 同一个盒子内的外边距合并 浮动导致的盒子高度塌陷 等，这些问题都可以通过触发BFC 来解决 "},"Base/Html/":{"url":"Base/Html/","title":"Html基础","keywords":"","body":"前端基础之css "},"Base/Javascript/":{"url":"Base/Javascript/","title":"Javascript基础","keywords":"","body":"前端基础之css "},"Base/Javascript/基础深入/":{"url":"Base/Javascript/基础深入/","title":"基础深入","keywords":"","body":"前端基础之css "},"Base/Javascript/基础深入/this指向.html":{"url":"Base/Javascript/基础深入/this指向.html","title":"this指向","keywords":"","body":"this是javascript中最常用到的关键词之一， javascript中this对象的指向问题是一个很重要的问题，理解并正确使用它是一个javascript开发者必须具备的能力。 this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。 调用位置 在理解 this 的绑定过程之前，首先要理解调用位置:调用位置就是函数在代码中被调用的 位置(而不是声明的位置)。只有仔细分析调用位置才能回答这个问题:这个 this 到底引 用的是什么? 最重要的是要分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的 调用位置就在当前正在执行的函数的前一个调用中。调用栈可以想象成一个函数调用链，在浏览器的调试工具中可以打断点来查看当前断点的调用栈信息 可以看到当前调用栈的位置在foo,下个调用位置是bar,在当前的调用环境下this 默认指向了windows对象。 绑定规则 我们来看看在函数的执行过程中调用位置如何决定 this 的绑定对象。 你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释 这四条规则，然后解释多条规则都可用时它们的优先级如何排列。 默认绑定 首先要介绍的是最常用的函数调用类型:独立函数调用。可以把这条规则看作是无法应用其他规则时的默认规则。 function foo() { console.log(this.a); } var a = 2; foo(); // 2 声明在全局作用域中的变量(比如 var a = 2)就是全局对象的一个同名属性。它们本质上就是同一个东西，并不是通过复制得到的。 当调用 foo() 时，this.a 被解析成了全局变量 a。因为函数调用时应用了 this 的默认绑定，因此 this 指向全局对象。 那么我们怎么知道这里应用了默认绑定呢?可以通过分析调用位置来看看 foo() 是如何调 用的。在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，其调用栈是处在全局作用域中，因此只能使用 默认绑定，无法应用其他规则。 注意 ：使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此 this 会绑定到undefined。 隐式绑定 另一条需要考虑的规则是调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。 function foo() { console.log( this.a ); } var obj = { a: 2, foo: foo }; obj.foo(); // 2 首先需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的。 但是无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象。 然而，调用位置会使用 obj 上下文来引用函数，因此你可以说函数被调用时 obj 对象\"拥 有\"或者\"包含\"它。 无论你如何称呼这个模式，当 foo() 被调用时，它的落脚点确实指向 obj 对象。当函数引 用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。因为调 用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。 对象属性引用链中只有最顶层或者说最后一层会影响调用位置。举例来说: function foo() { console.log(this.a); } var obj2 = { a: 42, foo: foo }; var obj1 = { a: 2, obj2: obj2 }; obj1.obj2.foo(); // 42 隐式丢失 当我们在用隐式绑定的时候可能会犯一个错误，被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者undefined 上，取决于是否是严格模式。 function foo() { console.log(this.a); } var obj = { a: 2, foo: foo }; var bar = obj.foo; // 函数别名! var a = \"oops, global\"; // a 是全局对象的属性 bar(); // \"oops, global\" 虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。 显式绑定 在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 this 间接(隐式)绑定到这个对象上。 那么如果我们不想在对象内部包含函数引用，而想在某个对象上强制调用函数，该怎么做呢? JavaScript 中的\"所有\"函数都有一些有用的特性可以用来解决这个问题。具体点说，可以使用函数的 call(..) 和 apply(..) 方法。严格来说，JavaScript 的宿主环境有时会提供一些非常特殊的函数，它们 并没有这两个方法。但是这样的函数非常罕见，JavaScript 提供的绝大多数函数以及你自 己创建的所有函数都可以使用call(..) 和 apply(..) 方法。 function foo() { console.log( this.a ); } var obj = { a:2 }; foo.call( obj ); // 2 通过 foo.call(..)，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。 硬绑定 显式绑定仍然无法解决我们之前提出的丢失绑定问题,但是显式绑定的一个变种可以解决这个问题。 function foo() { console.log(this.a); } var obj = { a: 2 }; var bar = function () { foo.call(obj); }; bar(); // 2 setTimeout(bar, 100); // 2 // 硬绑定的 bar 不可能再修改它的 this bar.call(window); // 2 我们创建了函数 bar()，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它 总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定。 硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值: function foo(something) { console.log(this.a, something); return this.a + something; } var obj = { a: 2 }; var bar = function () { return foo.apply(obj, arguments); }; var b = bar(3); // 2 3 console.log(b); // 5 new绑定 在传统的面向类的语言中，\"构造函数\"是类中的一些特殊方法，使用 new 初始化类时会 调用类中的构造函数。通常的形式是这样的: something = new MyClass(..); JavaScript 也有一个 new 操作符，使用方法看起来也和那些面向类的语言一样，绝大多数开 发者都认为 JavaScript 中 new 的机制也和那些语言一样。然而，JavaScript 中 new 的机制实 际上和面向类的语言完全不同。 首先我们重新定义一下 JavaScript 中的\"构造函数\"。在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。 举例来说，思考一下 Number(..) 作为构造函数时的行为，ES5.1 中这样描述它: 15.7.2 Number 构造函数当 Number 在 new 表达式中被调用时，它是一个构造函数:它会初始化新创建的 对象。 所以，包括内置对象函数(比如 Number(..))在内的所有函数都可 以用 new 来调用，这种函数调用被称为构造函数调用。这里有一个重要但是非常细微的区 别:实际上并不存在所谓的\"构造函数\"，只有对于函数的\"构造调用\"。 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建(或者说构造)一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的this。 如果函数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。 function foo(a) { this.a = a; } var bar = new foo(2); console.log(bar.a); // 2 使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。new 是最后一种可以影响函数调用时 this 绑定行为的方法，我们称之为 new 绑定。 优先级 现在我们已经了解了函数调用中 this 绑定的四条规则，你需要做的就是找到函数的调用位 置并判断应当应用哪条规则。但是，如果某个调用位置可以应用多条规则该怎么办?为了 解决这个问题就必须给这些规则设定优先级，这就是我们接下来要介绍的内容。毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们可以先不考虑它。 隐式绑定和显式绑定哪个优先级更高?我们来测试一下: function foo() { console.log(this.a); } var obj1 = { a: 2, foo: foo }; var obj2 = { a: 3, foo: foo }; obj1.foo(); // 2 obj2.foo(); // 3 obj1.foo.call(obj2); // 3 obj2.foo.call(obj1); // 2 可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以应用显式绑定。 现在我们需要搞清楚 new 绑定和隐式绑定的优先级谁高谁低: function foo(something) { this.a = something; } var obj1 = { foo: foo }; var obj2 = {}; obj1.foo(2); console.log(obj1.a); // 2 obj1.foo.call(obj2, 3); console.log(obj2.a); // 3 var bar = new obj1.foo(4); console.log(obj1.a); // 2 console.log(bar.a); // 4 可以看到 new 绑定比隐式绑定优先级高。但是 new 绑定和显式绑定谁的优先级更高呢? new 和 call/apply 无法一起使用，因此无法通过 new foo.call(obj1) 来直接 进行测试。但是我们可以使用硬绑定来测试它俩的优先级。 function foo(something) { this.a = something; } var obj1 = {}; var bar = foo.bind(obj1); bar(2); console.log(obj1.a); // 2 var baz = new bar(3); console.log(obj1.a); // 2 console.log(baz.a); // 3 出乎意料! bar 被硬绑定到 obj1 上，但是 new bar(3)并没有向我们预料的那样把obj1.a修改为 3。相反，new 修改了硬绑定(到 obj1 的)调用 bar(..) 中的 this。因为使用了 new 绑定，我们得到了一个名字为 baz 的新对象，并且 baz.a 的值是 3。 判断this 现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的 顺序来进行判断: 函数是否在new中调用(new绑定)?如果是的话this绑定的是新创建的对象。 var bar = new foo() 函数是否通过call、apply(显式绑定)或者硬绑定调用?如果是的话，this绑定的是 指定的对象。 var bar = foo.call(obj2) 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。 var bar = obj1.foo() 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到 全局对象。 var bar = foo() 就是这样。 对于正常的函数调用来说，理解了这些知识你就可以明白 this 的绑定原理了。 不过......凡事总有例外。 "},"Base/Javascript/专题/":{"url":"Base/Javascript/专题/","title":"专题深入","keywords":"","body":"前端基础之css "},"Base/Javascript/专题/跨域.html":{"url":"Base/Javascript/专题/跨域.html","title":"跨域","keywords":"","body":"什么是跨域？ 跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。 广义的跨域： 资源跳转： A链接、重定向、表单提交 资源嵌入： link、script、img、frame 等dom标签，还有样式中background:url()、@font-face()等文件外链 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等 其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。 什么是同源策略？ 同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指\"协议+域名+端口\"三者相同，即便两个不同的域名指向同一个ip地址，也非同源。 同源策略限制以下几种行为： Cookie、LocalStorage 和 IndexDB 无法读取 DOM 和 Js对象无法获得 AJAX 请求不能发送; 常见跨域场景 跨域解决方案 通过jsonp跨域 document.domain + iframe跨域 location.hash + iframe window.name + iframe跨域 postMessage跨域 跨域资源共享（CORS） nginx代理跨域 nodejs中间件代理跨域 WebSocket协议跨域 一、 通过jsonp跨域 通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。 原生实现： var script = document.createElement('script'); script.type = 'text/javascript'; // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数 script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback'; document.head.appendChild(script); // 回调执行函数 function handleCallback(res) { alert(JSON.stringify(res)); } 服务端返回如下（返回时即执行全局函数）： handleCallback({\"status\": true, \"user\": \"admin\"}) jquery ajax： $.ajax({ url: 'http://www.domain2.com:8080/login', type: 'get', dataType: 'jsonp', // 请求方式为jsonp jsonpCallback: \"handleCallback\", // 自定义回调函数名 data: {} }); vue.js： this.$http.jsonp('http://www.domain2.com:8080/login', { params: {}, jsonp: 'handleCallback' }).then((res) => { console.log(res); }) 后端node.js代码示例： var querystring = require('querystring'); var http = require('http'); var server = http.createServer(); server.on('request', function(req, res) { var params = qs.parse(req.url.split('?')[1]); var fn = params.callback; // jsonp返回设置 res.writeHead(200, { 'Content-Type': 'text/javascript' }); res.write(fn + '(' + JSON.stringify(params) + ')'); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); jsonp缺点：只能实现get一种请求。 二、 document.domain + iframe跨域 此方案仅限主域相同，子域不同的跨域应用场景。 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。 父窗口：(http://www.domain.com/a.html) document.domain = 'domain.com'; var user = 'admin'; 子窗口：(http://child.domain.com/b.html) document.domain = 'domain.com'; // 获取父窗口中变量 alert('get js data from parent ---> ' + window.parent.user); 三、 location.hash + iframe跨域 实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。 具体实现：A域：a.html -> B域：b.html -> A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。 a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById('iframe'); // 向b.html传hash值 setTimeout(function() { iframe.src = iframe.src + '#user=admin'; }, 1000); // 开放给同域c.html的回调方法 function onCallback(res) { alert('data from c.html ---> ' + res); } b.html：(http://www.domain2.com/b.html) var iframe = document.getElementById('iframe'); // 监听a.html传来的hash值，再传给c.html window.onhashchange = function () { iframe.src = iframe.src + location.hash; }; c.html：(http://www.domain1.com/c.html) // 监听b.html传来的hash值 window.onhashchange = function () { // 再通过操作同域a.html的js回调，将结果传回 window.parent.parent.onCallback('hello: ' + location.hash.replace('#user=', '')); }; 四、 window.name + iframe跨域 window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。 1.）a.html：(http://www.domain1.com/a.html) var proxy = function(url, callback) { var state = 0; var iframe = document.createElement('iframe'); // 加载跨域页面 iframe.src = url; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name iframe.onload = function() { if (state === 1) { // 第2次onload(同域proxy页)成功后，读取同域window.name中数据 callback(iframe.contentWindow.name); destoryFrame(); } else if (state === 0) { // 第1次onload(跨域页)成功后，切换到同域代理页面 iframe.contentWindow.location = 'http://www.domain1.com/proxy.html'; state = 1; } }; document.body.appendChild(iframe); // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问） function destoryFrame() { iframe.contentWindow.document.write(''); iframe.contentWindow.close(); document.body.removeChild(iframe); } }; // 请求跨域b页面数据 proxy('http://www.domain2.com/b.html', function(data){ alert(data); }); proxy.html：(http://www.domain1.com/proxy.... 中间代理页，与a.html同域，内容为空即可。 b.html：(http://www.domain2.com/b.html) window.name = 'This is domain2 data!'; 总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 五、 postMessage跨域 postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题： a. 页面和其打开的新窗口的数据传递 b. 多窗口之间消息传递 c. 页面与嵌套的iframe消息传递 d. 上面三个场景的跨域数据传递 用法：postMessage(data,origin)方法接受两个参数data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。origin： 协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。 a.html：(http://www.domain1.com/a.html) var iframe = document.getElementById('iframe'); iframe.onload = function() { var data = { name: 'aym' }; // 向domain2传送跨域数据 iframe.contentWindow.postMessage(JSON.stringify(data), 'http://www.domain2.com'); }; // 接受domain2返回数据 window.addEventListener('message', function(e) { alert('data from domain2 ---> ' + e.data); }, false); b.html：(http://www.domain2.com/b.html) // 接收domain1的数据 window.addEventListener('message', function(e) { alert('data from domain1 ---> ' + e.data); var data = JSON.parse(e.data); if (data) { data.number = 16; // 处理后再发回domain1 window.parent.postMessage(JSON.stringify(data), 'http://www.domain1.com'); } }, false); 六、 跨域资源共享（CORS） 普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。 前端设置： 原生ajax // 前端设置是否带cookie xhr.withCredentials = true; 示例代码： var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容 // 前端设置是否带cookie xhr.withCredentials = true; xhr.open('post', 'http://www.domain2.com:8080/login', true); xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); xhr.send('user=admin'); xhr.onreadystatechange = function() { if (xhr.readyState == 4 && xhr.status == 200) { alert(xhr.responseText); } }; jQuery ajax $.ajax({ ... xhrFields: { withCredentials: true // 前端设置是否带cookie }, crossDomain: true, // 会让请求头中包含跨域的额外信息，但不会含cookie ... }); vue框架axios设置：axios.defaults.withCredentials = truevue-resource设置：Vue.http.options.credentials = true 服务端设置： 若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。 Java后台： /* * 导入包：import javax.servlet.http.HttpServletResponse; * 接口参数中定义：HttpServletResponse response */ // 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加'/' response.setHeader(\"Access-Control-Allow-Origin\", \"http://www.domain1.com\"); // 允许前端带认证cookie：启用此项后，上面的域名不能为'*'，必须指定具体的域名，否则浏览器会提示 response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); // 提示OPTIONS预检时，后端需要设置的两个常用自定义头 response.setHeader(\"Access-Control-Allow-Headers\", \"Content-Type,X-Requested-With\"); Nodejs后台示例： var http = require('http'); var server = http.createServer(); var qs = require('querystring'); server.on('request', function(req, res) { var postData = ''; // 数据块接收中 req.addListener('data', function(chunk) { postData += chunk; }); // 数据接收完毕 req.addListener('end', function() { postData = qs.parse(postData); // 跨域后台设置 res.writeHead(200, { 'Access-Control-Allow-Credentials': 'true', // 后端允许发送Cookie 'Access-Control-Allow-Origin': 'http://www.domain1.com', // 允许访问的域（协议+域名+端口） /* * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)， * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问 */ 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly的作用是让js无法读取cookie }); res.write(JSON.stringify(postData)); res.end(); }); }); server.listen('8080'); console.log('Server is running at port 8080...'); 七、 nginx代理跨域 1、 nginx配置解决iconfont跨域浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。 location / { add_header Access-Control-Allow-Origin *; } 2、 nginx反向代理接口跨域跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。nginx具体配置： #proxy服务器 server { listen 81; server_name www.domain1.com; location / { proxy_pass http://www.domain2.com:8080; #反向代理 proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名 index index.html index.htm; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用 add_header Access-Control-Allow-Origin http://www.domain1.com; #当前端只跨域不带cookie时，可为* add_header Access-Control-Allow-Credentials true; } } 前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问nginx中的代理服务器 xhr.open('get', 'http://www.domain1.com:81/?user=admin', true); xhr.send(); Nodejs后台示例： var http = require('http'); var server = http.createServer(); var qs = require('querystring'); server.on('request', function(req, res) { var params = qs.parse(req.url.substring(2)); // 向前台写cookie res.writeHead(200, { 'Set-Cookie': 'l=a123456;Path=/;Domain=www.domain2.com;HttpOnly' // HttpOnly:脚本无法读取 }); res.write(JSON.stringify(params)); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); 八、 Nodejs中间件代理跨域 node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。1、 非vue框架的跨域（2次跨域）利用node + express + http-proxy-middleware搭建一个proxy服务器。 前端代码示例： var xhr = new XMLHttpRequest(); // 前端开关：浏览器是否读写cookie xhr.withCredentials = true; // 访问http-proxy-middleware代理服务器 xhr.open('get', 'http://www.domain1.com:3000/login?user=admin', true); xhr.send(); 中间件服务器： var express = require('express'); var proxy = require('http-proxy-middleware'); var app = express(); app.use('/', proxy({ // 代理跨域目标接口 target: 'http://www.domain2.com:8080', changeOrigin: true, // 修改响应头信息，实现跨域并允许带cookie onProxyRes: function(proxyRes, req, res) { res.header('Access-Control-Allow-Origin', 'http://www.domain1.com'); res.header('Access-Control-Allow-Credentials', 'true'); }, // 修改响应信息中的cookie域名 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 })); app.listen(3000); console.log('Proxy server is listen at port 3000...'); Nodejs后台同（六：nginx） 2、 vue框架的跨域（1次跨域）利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。webpack.config.js部分配置： module.exports = { entry: {}, module: {}, ... devServer: { historyApiFallback: true, proxy: [{ context: '/login', target: 'http://www.domain2.com:8080', // 代理跨域目标接口 changeOrigin: true, secure: false, // 当代理某些https服务报错时用 cookieDomainRewrite: 'www.domain1.com' // 可以为false，表示不修改 }], noInfo: true } } 九、 WebSocket协议跨域 WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。 前端代码： user input： var socket = io('http://www.domain2.com:8080'); // 连接成功处理 socket.on('connect', function() { // 监听服务端消息 socket.on('message', function(msg) { console.log('data from server: ---> ' + msg); }); // 监听服务端关闭 socket.on('disconnect', function() { console.log('Server socket has closed.'); }); }); document.getElementsByTagName('input')[0].onblur = function() { socket.send(this.value); }; Nodejs socket后台： var http = require('http'); var socket = require('socket.io'); // 启http服务 var server = http.createServer(function(req, res) { res.writeHead(200, { 'Content-type': 'text/html' }); res.end(); }); server.listen('8080'); console.log('Server is running at port 8080...'); // 监听socket连接 socket.listen(server).on('connection', function(client) { // 接收信息 client.on('message', function(msg) { client.send('hello：' + msg); console.log('data from client: ---> ' + msg); }); // 断开处理 client.on('disconnect', function() { console.log('Client socket has closed.'); }); }); "},"Algorithm/DataStructure/":{"url":"Algorithm/DataStructure/","title":"数据结构","keywords":"","body":"前端基础之css "},"Algorithm/Algorithm/":{"url":"Algorithm/Algorithm/","title":"算法","keywords":"","body":"前端基础之css "},"Tool/Yarn/":{"url":"Tool/Yarn/","title":"Yarn","keywords":"","body":""},"Tool/Npm/":{"url":"Tool/Npm/","title":"Npm","keywords":"","body":""},"Tool/Npm/npm常用命令.html":{"url":"Tool/Npm/npm常用命令.html","title":"npm常用命令","keywords":"","body":"npm 常用命令行总结 npm是什么 NPM的全称是Node Package Manager，是随同NodeJS一起安装的包管理和分发工具，它很方便让JavaScript开发者下载、安装、上传以及管理已经安装的包。 npm install安装模块 基础语法 ``` javascript npm install (with no args, in package dir) npm install [/] npm install [/]@ npm install [/]@ npm install [/]@ npm install npm install npm install alias: npm i common options: [-S|--save|-D|--save-dev|-O|--save-optional] [-E|--save-exact] [--dry-run] 安装包，默认会安装最新的版本 #### npm uninstall 卸载模块 - 基础语法 ``` javascript npm uninstall [/][@]... [-S|--save|-D|--save-dev|-O|--save-optional] aliases: remove, rm, r, un, unlink npm update 更新模块 基础语法npm update [-g] [...] npm outdated 检查模块是否已经过时 基础语法npm outdated [[/] ...] npm ls 查看安装的模块 基础语法npm ls [[/] ...] aliases: list, la, ll 查看全局安装的模块及依赖 npm ls -g npm init 在项目中引导创建一个package.json文件 安装包的信息可保持到项目的package.json文件中，以便后续的其它的项目开发或者他人合作使用，也说package.json在项目中是必不可少的 基础语法npm init [-f|--force|-y|--yes] npm help 查看某条命令的详细帮助 基础语法npm help [] 例如输入npm help install，系统在默认的浏览器或者默认的编辑器中打开本地nodejs安装包的文件/nodejs/node_modules/npm/html/doc/cli/npm-install.htmlnpm help install npm root 查看包的安装路径 输出 node_modules的路径 npm root [-g] npm config 管理npm的配置路径 基础语法npm config set [-g|--global] npm config get npm config delete npm config list npm config edit npm get npm set [-g|--global] 经常用于设置镜像npm config set registry=\"http://r.cnpmjs.org\" 如安装淘宝镜像npm install -g cnpm --registry=https://registry.npm.taobao.org npm cache 管理模块的缓存 基础语法npm cache add npm cache add npm cache add npm cache add @ npm cache ls [] npm cache clean [] 最常用命令清除npm本地缓存npm cache clean npm start 启动模块 基础语法npm start [-- ] 该命令写在package.json文件scripts的start字段中，可以自定义命令来配置一个服务器环境和安装一系列的必要程序，如\"scripts\": { \"start\": \"gulp -ws\" } 此时在cmd中输入npm start命令相当于执行gulpfile.js文件自定义的watch和server命令。 如果package.json文件没有设置start，则将直接启动node server.js npm stop 停止模块 基础语法npm stop [-- ] npm restart 重新启动模块 基础语法npm restart [-- ] npm test 测试模块 基础语法npm test [-- ] npm tst [-- ] 该命令写在package.json文件scripts的test字段中，可以自定义该命令来执行一些操作，如\"scripts\": { \"test\": \"gulp release\" }, 此时在cmd中输入npm test命令相当于执行gulpfile.js文件自定义的release命令。 npm version 查看模块版本 基础语法 ``` javascript npm version [ | major | minor | patch | premajor | preminor | prepatch | prerelease | from-git] 'npm [-v | --version]' to print npm version 'npm view version' to view a package's published version 'npm ls' to inspect current package/dependency versions 查看模块的版本 ``` javascript npm version 例： { store_eve: '0.1.0', npm: '6.9.0', ares: '1.10.1-DEV', cldr: '32.0', http_parser: '2.8.0', icu: '60.1', modules: '57', nghttp2: '1.25.0', node: '8.11.1', openssl: '1.0.2o', tz: '2017c', unicode: '10.0', uv: '1.19.1', v8: '6.2.414.50', zlib: '1.2.11' } npm view 查看模块的注册信息 基础语法 ``` javascript npm view [/][@] [[.]...] aliases: info, show, v 查看模块的依赖关系 ``` javascript npm view gulp dependencies 查看模块的源文件地址 npm view gulp repository.url 查看模块的贡献者，包含邮箱地址 npm view npm contributors npm adduser 用户登录 基础语法npm adduser [--registry=url] [--scope=@orgname] [--always-auth] 发布模板到npm社区前需要先登录，然后再进入发布的操作 npm publish 发布模块 基础语法 ``` javascript npm publish [|] [--tag ] [--access ] Publishes '.' if no argument supplied Sets tag 'latest' if no --tag specified #### npm access 在发布的包上设置访问级别 - 基础语法 ``` javascript npm access public [] npm access restricted [] npm access grant [] npm access revoke [] npm access ls-packages [||] npm access ls-collaborators [ []] npm access edit [] "},"Base/Javascript/基础深入/从原型到原型链.html":{"url":"Base/Javascript/基础深入/从原型到原型链.html","title":"从原型到原型链","keywords":"","body":"构造函数创建对象 我们先使用构造函数创建一个对象： function Person() { } var person = new Person(); person.name = 'Kevin'; console.log(person.name) // Kevin 在这个例子中，Person 就是一个构造函数，我们使用 new 创建了一个实例对象 person。 很简单吧，接下来进入正题： prototype 每个函数都有一个 prototype 属性，就是我们经常在各种例子中看到的那个 prototype ，比如： function Person() { } // 虽然写在注释里，但是你要注意： // prototype是函数才会有的属性 Person.prototype.name = 'Kevin'; var person1 = new Person(); var person2 = new Person(); console.log(person1.name) // Kevin console.log(person2.name) // Kevin 那这个函数的 prototype 属性到底指向的是什么呢？是这个函数的原型吗？ 其实，函数的 prototype 属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型，也就是这个例子中的 person1 和 person2 的原型。 那什么是原型呢？你可以这样理解：每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型\"继承\"属性。 让我们用一张图表示构造函数和实例原型之间的关系： 在这张图中我们用 Object.prototype 表示实例原型。 那么我们该怎么表示实例与实例原型，也就是 person 和 Person.prototype 之间的关系呢，这时候我们就要讲到第二个属性： proto 这是每一个JavaScript对象(除了 null )都具有的一个属性，叫proto，这个属性会指向该对象的原型。 为了证明这一点,我们可以在火狐或者谷歌中输入： function Person() { } var person = new Person(); console.log(person.__proto__ === Person.prototype); // true 于是我们更新下关系图： 既然实例对象和构造函数都可以指向原型，那么原型是否有属性指向构造函数或者实例呢？ constructor 指向实例倒是没有，因为一个构造函数可以生成多个实例，但是原型指向构造函数倒是有的，这就要讲到第三个属性：constructor，每个原型都有一个 constructor 属性指向关联的构造函数。 为了验证这一点，我们可以尝试： function Person() { } console.log(Person === Person.prototype.constructor); // true 所以再更新下关系图： 综上我们已经得出： function Person() { } var person = new Person(); console.log(person.__proto__ == Person.prototype) // true console.log(Person.prototype.constructor == Person) // true // 顺便学习一个ES5的方法,可以获得对象的原型 console.log(Object.getPrototypeOf(person) === Person.prototype) // true 了解了构造函数、实例原型、和实例之间的关系，接下来我们讲讲实例和原型的关系： 实例与原型 当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。 举个例子： function Person() { } Person.prototype.name = 'Kevin'; var person = new Person(); person.name = 'Daisy'; console.log(person.name) // Daisy delete person.name; console.log(person.name) // Kevin 在这个例子中，我们给实例对象 person 添加了 name 属性，当我们打印 person.name 的时候，结果自然为 Daisy。 但是当我们删除了 person 的 name 属性时，读取 person.name，从 person 对象中找不到 name 属性就会从 person 的原型也就是 person.proto ，也就是 Person.prototype中查找，幸运的是我们找到了 name 属性，结果为 Kevin。 但是万一还没有找到呢？原型的原型又是什么呢？ 原型的原型 在前面，我们已经讲了原型也是一个对象，既然是对象，我们就可以用最原始的方式创建它，那就是： var obj = new Object(); obj.name = 'Kevin' console.log(obj.name) // Kevin 其实原型对象就是通过 Object 构造函数生成的，结合之前所讲，实例的 proto 指向构造函数的 prototype ，所以我们再更新下关系图： 原型链 那 Object.prototype 的原型呢？ null，我们可以打印： console.log(Object.prototype.__proto__ === null) // true 然而 null 究竟代表了什么呢？ 引用阮一峰老师的 《undefined与null的区别》 就是： null 表示“没有对象”，即该处不应该有值。 所以 Object.prototype.proto 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。 所以查找属性的时候查到 Object.prototype 就可以停止查找了。 最后一张关系图也可以更新为： 顺便还要说一下，图中由相互关联的原型组成的链状结构就是原型链，也就是蓝色的这条线。 补充 最后，补充三点大家可能不会注意的地方： constructor 首先是 constructor 属性，我们看个例子： function Person() { } var person = new Person(); console.log(person.constructor === Person); // true 当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以： person.constructor === Person.prototype.constructor proto 其次是 proto ，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter/setter，当使用 obj.proto 时，可以理解成返回了 Object.getPrototypeOf(obj)。 真的是继承吗？ 最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的JavaScript》中的话，就是： 继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。 "},"Base/Javascript/基础深入/变量对象.html":{"url":"Base/Javascript/基础深入/变量对象.html","title":"变量对象","keywords":"","body":"前言 在上篇《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 今天重点讲讲创建变量对象的过程。 变量对象 变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。 因为不同执行上下文下的变量对象稍有不同，所以我们来聊聊全局上下文下的变量对象和函数上下文下的变量对象。 全局上下文 我们先了解一个概念，叫全局对象。在 W3School 中也有介绍： 全局对象是预定义的对象，作为 JavaScript 的全局函数和全局属性的占位符。通过使用全局对象，可以访问所有其他所有预定义的对象、函数和属性。 在顶层 JavaScript 代码中，可以用关键字 this 引用全局对象。因为全局对象是作用域链的头，这意味着所有非限定性的变量和函数名都会作为该对象的属性来查询。 例如，当JavaScript 代码引用 parseInt() 函数时，它引用的是全局对象的 parseInt 属性。全局对象是作用域链的头，还意味着在顶层 JavaScript 代码中声明的所有变量都将成为全局对象的属性。 如果看的不是很懂的话，容我再来介绍下全局对象: 1.可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象。 console.log(this); 2.全局对象是由 Object 构造函数实例化的一个对象。 console.log(this instanceof Object); 3.预定义了一堆，嗯，一大堆函数和属性。 // 都能生效 console.log(Math.random()); console.log(this.Math.random()); 4.作为全局变量的宿主。 var a = 1; console.log(this.a); 5.客户端 JavaScript 中，全局对象有 window 属性指向自身。 var a = 1; console.log(window.a); this.window.b = 2; console.log(this.b); 花了一个大篇幅介绍全局对象，其实就想说： 全局上下文中的变量对象就是全局对象呐！ 函数上下文 在函数上下文中，我们用活动对象(activation object, AO)来表示变量对象。 活动对象和变量对象其实是一个东西，只是变量对象是规范上的或者说是引擎实现上的，不可在 JavaScript 环境中访问，只有到当进入一个执行上下文中，这个执行上下文的变量对象才会被激活，所以才叫 activation object 呐，而只有被激活的变量对象，也就是活动对象上的各种属性才能被访问。 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性值是 Arguments 对象。 执行过程 执行上下文的代码会分成两个阶段进行处理：分析和执行，我们也可以叫做： 进入执行上下文 代码执行 进入执行上下文 当进入执行上下文时，这时候还没有执行代码， 变量对象会包括： 函数的所有形参 (如果是函数上下文) 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为 undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建； 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 举个例子：function foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); 在进入执行上下文后，这时候的 AO 是：AO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 在代码执行阶段，会顺序执行代码，根据代码，修改变量对象的值 还是上面的例子，当代码执行完后，这时候的 AO 是： AO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression \"d\" } 到这里变量对象的创建过程就介绍完了，让我们简洁的总结我们上述所说： 全局上下文的变量对象初始化是全局对象 函数上下文的变量对象初始化只包括 Arguments 对象 在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值 在代码执行阶段，会再次修改变量对象的属性值 思考题 最后让我们看几个例子： 1.第一题 function foo() { console.log(a); a = 1; } foo(); // ??? function bar() { a = 1; console.log(a); } bar(); // ??? 第一段会报错：Uncaught ReferenceError: a is not defined。 第二段会打印：1。 这是因为函数中的 \"a\" 并没有通过 var 关键字声明，所有不会被存放在 AO 中。 第一段执行 console 的时候， AO 的值是： AO = { arguments: { length: 0 } } 没有 a 的值，然后就会到全局去找，全局也没有，所以会报错。 当第二段执行 console 的时候，全局对象已经被赋予了 a 属性，这时候就可以从全局找到 a 的值，所以会打印 1。 2.第二题 console.log(foo); function foo(){ console.log(\"foo\"); } var foo = 1; 会打印函数，而不是 undefined 。 这是因为在进入执行上下文时，首先会处理函数声明，其次会处理变量声明，如果如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。 "},"Base/Javascript/基础深入/执行上下文栈.html":{"url":"Base/Javascript/基础深入/执行上下文栈.html","title":"执行上下文栈","keywords":"","body":"顺序执行？ 如果要问到 JavaScript 代码执行顺序的话，想必写过 JavaScript 的开发者都会有个直观的印象，那就是顺序执行，毕竟： var foo = function () { console.log('foo1'); } foo(); // foo1 var foo = function () { console.log('foo2'); } foo(); // foo2 然而去看这段代码： function foo() { console.log('foo1'); } foo(); // foo2 function foo() { console.log('foo2'); } foo(); // foo2 打印的结果却是两个 foo2。 刷过面试题的都知道这是因为 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 但是本文真正想让大家思考的是：这个“一段一段”中的“段”究竟是怎么划分的呢？ 到底JavaScript引擎遇到一段怎样的代码时才会做“准备工作”呢？ 可执行代码 这就要说到 JavaScript 的可执行代码(executable code)的类型有哪些了？ 其实很简单，就三种，全局代码、函数代码、eval代码。 举个例子，当执行到一个函数的时候，就会进行准备工作，这里的“准备工作”，让我们用个更专业一点的说法，就叫做\"执行上下文(execution context)\"。 执行上下文栈 接下来问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？ 所以 JavaScript 引擎创建了执行上下文栈（Execution context stack，ECS）来管理执行上下文 为了模拟执行上下文栈的行为，让我们定义执行上下文栈是一个数组： ECStack = []; 试想当 JavaScript 开始要解释执行代码的时候，最先遇到的就是全局代码，所以初始化的时候首先就会向执行上下文栈压入一个全局执行上下文，我们用 globalContext 表示它，并且只有当整个应用程序结束的时候，ECStack 才会被清空，所以程序结束之前， ECStack 最底部永远有个 globalContext： ECStack = [ globalContext ]; 现在 JavaScript 遇到下面的这段代码了： function fun3() { console.log('fun3') } function fun2() { fun3(); } function fun1() { fun2(); } fun1(); 当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。知道了这样的工作原理，让我们来看看如何处理上面这段代码： // 伪代码 // fun1() ECStack.push( functionContext); // fun1中竟然调用了fun2，还要创建fun2的执行上下文 ECStack.push( functionContext); // 擦，fun2还调用了fun3！ ECStack.push( functionContext); // fun3执行完毕 ECStack.pop(); // fun2执行完毕 ECStack.pop(); // fun1执行完毕 ECStack.pop(); // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 解答思考题 好啦，现在我们已经了解了执行上下文栈是如何处理执行上下文的，所以让我们看看上篇文章《JavaScript深入之词法作用域和动态作用域》最后的问题： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 答案就是执行上下文栈的变化不一样。 让我们模拟第一段代码： ECStack.push( functionContext); ECStack.push( functionContext); ECStack.pop(); ECStack.pop(); 让我们模拟第二段代码： ECStack.push( functionContext); ECStack.pop(); ECStack.push( functionContext); ECStack.pop(); 是不是有些不同呢？ 当然了，这样概括的回答执行上下文栈的变化不同，是不是依然有一种意犹未尽的感觉呢，为了更详细讲解两个函数执行上的区别，我们需要探究一下执行上下文到底包含了哪些内容，所以欢迎阅读下一篇《JavaScript深入之变量对象》。 "},"Base/Javascript/基础深入/执行上下文.html":{"url":"Base/Javascript/基础深入/执行上下文.html","title":"执行上下文","keywords":"","body":"前言 在《JavaScript深入之执行上下文栈》中讲到，当 JavaScript 代码执行一段可执行代码(executable code)时，会创建对应的执行上下文(execution context)。 对于每个执行上下文，都有三个重要属性： 变量对象(Variable object，VO) 作用域链(Scope chain) this 然后分别在《JavaScript深入之变量对象》、《JavaScript深入之作用域链》、《JavaScript深入之从ECMAScript规范解读this》中讲解了这三个属性。 阅读本文前，如果对以上的概念不是很清楚，希望先阅读这些文章。 因为，这一篇，我们会结合着所有内容，讲讲执行上下文的具体处理过程。 思考题 在《JavaScript深入之词法作用域和动态作用域》中，提出这样一道思考题： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 两段代码都会打印'local scope'。虽然两段代码执行的结果一样，但是两段代码究竟有哪些不同呢？ 紧接着就在下一篇《JavaScript深入之执行上下文栈》中，讲到了两者的区别在于执行上下文栈的变化不一样，然而，如果是这样笼统的回答，依然显得不够详细，本篇就会详细的解析执行上下文栈和执行上下文的具体变化过程。 具体执行分析 我们分析第一段代码： var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f(); } checkscope(); 执行过程如下： 1.执行全局代码，创建全局执行上下文，全局上下文被压入执行上下文栈 ECStack = [ globalContext ]; 2.全局上下文初始化 globalContext = { VO: [global], Scope: [globalContext.VO], this: globalContext.VO } 2.初始化的同时，checkscope 函数被创建，保存作用域链到函数的内部属性[[scope]] checkscope.[[scope]] = [ globalContext.VO ]; 3.执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 函数执行上下文被压入执行上下文栈 ECStack = [ checkscopeContext, globalContext ]; 4.checkscope 函数执行上下文初始化： 复制函数 [[scope]] 属性创建作用域链， 用 arguments 创建活动对象， 初始化活动对象，即加入形参、函数声明、变量声明， 将活动对象压入 checkscope 作用域链顶端。 同时 f 函数被创建，保存作用域链到 f 函数的内部属性[[scope]] checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to function f(){} }, Scope: [AO, globalContext.VO], this: undefined } 5.执行 f 函数，创建 f 函数执行上下文，f 函数执行上下文被压入执行上下文栈 ECStack = [ fContext, checkscopeContext, globalContext ]; 6.f 函数执行上下文初始化, 以下跟第 4 步相同： 复制函数 [[scope]] 属性创建作用域链 用 arguments 创建活动对象 初始化活动对象，即加入形参、函数声明、变量声明 将活动对象压入 f 作用域链顶端 fContext = { AO: { arguments: { length: 0 } }, Scope: [AO, checkscopeContext.AO, globalContext.VO], this: undefined } 7.f 函数执行，沿着作用域链查找 scope 值，返回 scope 值 8.f 函数执行完毕，f 函数上下文从执行上下文栈中弹出 ECStack = [ checkscopeContext, globalContext ]; 9.checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出 ECStack = [ globalContext ]; 第二段代码就留给大家去尝试模拟它的执行过程。 var scope = \"global scope\"; function checkscope(){ var scope = \"local scope\"; function f(){ return scope; } return f; } checkscope()(); 不过，在下一篇《JavaScript深入之闭包》中也会提及这段代码的执行过程。 "}}